import type { VercelRequest, VercelResponse } from '@vercel/node';
import { fetchCategories, fetchEntriesFromDate, fetchEntries } from './miniflux';

// api to fetch all category names and entry amount for a given time frame
// Import the functions you need from the SDKs you need

import { initializeApp } from "firebase/app";
import { getDatabase, ref, set, child, get, push } from "firebase/database";

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries
// Your web app's Firebase configuration

const firebaseConfig = {
  apiKey: "AIzaSyAjUuRcI_R2eZvomfLcqAlEYhuz-czy5Nw",
  authDomain: "miniflux-binder.firebaseapp.com",
  databaseURL: "https://miniflux-binder-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "miniflux-binder",
  storageBucket: "miniflux-binder.appspot.com",
  messagingSenderId: "939682911095",
  appId: "1:939682911095:web:ace17aa62970080a6fc772"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

export default async function (request: VercelRequest, response: VercelResponse) {
  const userToken = request.body.userToken
  const userUrl = request.body.userUrl
  const days = request.body.days

  // call miniflux api to get all the categories with provided API token and then return categories in response

  // want to fetch all categories
  const categories = await fetchCategories(userToken, userUrl)

  // we have all the ids
  const formattedCategories = categories.map(c => ({ id: c.id, title: c.title }))

  //get entreis for each categories
  //with Asynchronous Mapping as using 'Promise.all' to await all the promises generated by the map function
  //later, entires also can be fetched as result.entires

  // put something into vercel key value store

  if (days) {
    const categoryWithAmount = await Promise.all(
      formattedCategories.map(async (category) => {
        const result = await fetchEntriesFromDate(category.id, days, userToken, userUrl)
        return ({
          categoryId: category.id,
          categoryTitle: category.title,
          total: result.total,
          entryId: result.entries.map(entry => entry.id),
          entries: result.entries,
          checked: false,
        })
      })
    )
    const serializedData = JSON.stringify(categoryWithAmount);
    const database = getDatabase();
    const dataRef = ref(database, 'data');
    await set(dataRef, categoryWithAmount);

    const snapshot = await get(dataRef);

    if (snapshot.exists()) {
      const data = snapshot.val();
      response.send(data);
    } else {
      response.status(404).send('Data not found');
    }
    //return response.send(testRes);
  } else {
    const categoryWithAmountAllPeriods = await Promise.all(
      formattedCategories.map(async (category) => {
        const result = await fetchEntries(category.id, userToken, userUrl)
        return ({
          categoryId: category.id,
          categoryTitle: category.title,
          total: result.total,
          entryId: result.entries.map(entry => entry.id),
          entries: result.entries,
          checked: false,
        })
      })
    )
    return response.send(categoryWithAmountAllPeriods);
  }

}